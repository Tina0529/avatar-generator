<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>GLM-Realtime è¯­éŸ³æµ‹è¯•</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, sans-serif; background: #0f0f1a; color: #e0e0f0; padding: 24px; min-height: 100vh; }
    h1 { font-size: 20px; margin-bottom: 20px; color: #a78bfa; }
    .card { background: #1a1a2e; border: 1px solid #2d2d4e; border-radius: 12px; padding: 20px; margin-bottom: 16px; }
    label { font-size: 13px; color: #888; display: block; margin-bottom: 6px; }
    input[type=text] { width: 100%; background: #0f0f1a; border: 1px solid #3d3d5e; color: #e0e0f0; padding: 10px 14px; border-radius: 8px; font-size: 14px; font-family: monospace; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 14px; }
    button { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.2s; }
    #btnConnect { background: #7c3aed; color: white; }
    #btnConnect:hover { background: #6d28d9; }
    #btnConnect.connected { background: #059669; }
    #btnConnect.connected:hover { background: #047857; }
    #btnMic { background: #1e40af; color: white; min-width: 120px; }
    #btnMic.active { background: #dc2626; animation: pulse 1s infinite; }
    #btnMic:disabled { opacity: 0.4; cursor: not-allowed; }
    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.7; } }
    .status { font-size: 13px; padding: 8px 12px; border-radius: 6px; background: #1e1e3a; margin-top: 10px; }
    .status.ok { color: #34d399; }
    .status.err { color: #f87171; }
    .status.info { color: #93c5fd; }
    #transcript { background: #0a0a1a; border: 1px solid #2d2d4e; border-radius: 8px; padding: 14px; min-height: 200px; max-height: 400px; overflow-y: auto; font-size: 14px; line-height: 1.6; }
    .msg-user { color: #93c5fd; margin-bottom: 8px; }
    .msg-user::before { content: 'ä½ : '; color: #60a5fa; font-weight: 600; }
    .msg-ai { color: #c4b5fd; margin-bottom: 8px; }
    .msg-ai::before { content: 'ğŸ¦Š GLM: '; color: #a78bfa; font-weight: 600; }
    .msg-sys { color: #6b7280; font-size: 12px; margin-bottom: 4px; font-style: italic; }
    select { background: #0f0f1a; border: 1px solid #3d3d5e; color: #e0e0f0; padding: 8px 12px; border-radius: 8px; font-size: 14px; }
  </style>
</head>
<body>

<h1>ğŸ¤ GLM-Realtime è¯­éŸ³æµ‹è¯•</h1>

<div class="card">
  <label>API Keyï¼ˆæ ¼å¼ï¼šid.secretï¼‰</label>
  <input type="text" id="apiKey" placeholder="xxxxxxxx.Xxxxxxxx" autocomplete="off">

  <div class="row">
    <div>
      <label style="margin-bottom:4px">è®¤è¯æ–¹å¼</label>
      <select id="authMode">
        <option value="raw">ç›´æ¥ API Keyï¼ˆç®€å•ï¼‰</option>
        <option value="jwt">JWT Tokenï¼ˆæ ‡å‡†ï¼‰</option>
      </select>
    </div>
    <div>
      <label style="margin-bottom:4px">åŒºåŸŸç«¯ç‚¹</label>
      <select id="region">
        <option value="wss://api.z.ai/api/paas/v4/realtime">ğŸŒ å›½é™…ç‰ˆ z.aiï¼ˆæµ·å¤–æ¨èï¼‰</option>
        <option value="wss://open.bigmodel.cn/api/paas/v4/realtime">ğŸ‡¨ğŸ‡³ å›½å†…ç‰ˆ bigmodel.cn</option>
      </select>
    </div>
    <div>
      <label style="margin-bottom:4px">æ¨¡å‹</label>
      <select id="model">
        <option value="glm-realtime-flash">GLM-Realtime-Flashï¼ˆä¾¿å®œï¼‰</option>
        <option value="glm-realtime-air">GLM-Realtime-Airï¼ˆè´µä¸€ç‚¹ï¼‰</option>
      </select>
    </div>
    <div>
      <label style="margin-bottom:4px">éŸ³è‰²</label>
      <select id="voice">
        <option value="tongtong">tongtongï¼ˆé€šç”¨å¥³å£°Â·é»˜è®¤ï¼‰</option>
        <option value="female-tianmei">female-tianmeiï¼ˆç”œç¾å¥³å£°ï¼‰</option>
        <option value="female-shaonv">female-shaonvï¼ˆå°‘å¥³éŸ³ï¼‰</option>
        <option value="lovely_girl">lovely_girlï¼ˆå¯çˆ±å¥³å­©ï¼‰</option>
        <option value="xiaochen">xiaochenï¼ˆé€šç”¨ç”·å£°ï¼‰</option>
        <option value="male-qn-daxuesheng">male-qn-daxueshengï¼ˆå¤§å­¦ç”Ÿç”·å£°ï¼‰</option>
        <option value="male-qn-jingying">male-qn-jingyingï¼ˆç²¾è‹±ç”·å£°ï¼‰</option>
      </select>
    </div>
    </div>
  </div>

  <div class="row">
    <button id="btnConnect" onclick="toggleConnect()">è¿æ¥</button>
    <button id="btnMic" onclick="toggleMic()" disabled>ğŸ¤ å¼€å§‹è¯´è¯</button>
  </div>

  <div id="statusBar" class="status info">è¯·è¾“å…¥ API Key åç‚¹å‡»è¿æ¥</div>
</div>

<div class="card">
  <label>å¯¹è¯è®°å½•</label>
  <div id="transcript"><div class="msg-sys">è¿æ¥åå¼€å§‹å¯¹è¯...</div></div>
</div>

<script>
// ====== JWT ç”Ÿæˆ ======
async function generateJWT(apiKey) {
  const parts = apiKey.split('.');
  if (parts.length < 2) throw new Error('API Key æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º id.secret');
  const id = parts[0];
  const secret = parts.slice(1).join('.');

  const header = { alg: 'HS256', sign_type: 'SIGN' };
  const nowMs = Date.now();  // æ¯«ç§’ï¼GLM è¦æ±‚æ¯«ç§’çº§æ—¶é—´æˆ³
  const payload = { api_key: id, exp: nowMs + 3600 * 1000, timestamp: nowMs };

  const b64url = (obj) => btoa(JSON.stringify(obj))
    .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');

  const signingInput = `${b64url(header)}.${b64url(payload)}`;

  const key = await crypto.subtle.importKey(
    'raw', new TextEncoder().encode(secret),
    { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(signingInput));
  const sigB64 = btoa(String.fromCharCode(...new Uint8Array(sig)))
    .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');

  return `${signingInput}.${sigB64}`;
}

// ====== UUID ç”Ÿæˆ ======
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

// ====== çŠ¶æ€ ======
let ws = null;
let isConnected = false;
let sessionReady = false;  // session.updated åæ‰çœŸæ­£å°±ç»ª
let isMicActive = false;
let audioContext = null;
let micStream = null;
let micWorklet = null;
let audioQueue = [];
let isPlayingAudio = false;
let currentAiText = '';
let currentUserText = '';
let pcmChunks = [];   // æ¨¡å—çº§ï¼ŒstopMic å¯ä»¥è®¿é—®åˆ°

function setStatus(msg, type = 'info') {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className = 'status ' + type;
}

function addMsg(type, text) {
  const div = document.getElementById('transcript');
  const p = document.createElement('p');
  p.className = 'msg-' + type;
  p.textContent = text;
  div.appendChild(p);
  div.scrollTop = div.scrollHeight;
}

function addSys(text) {
  const div = document.getElementById('transcript');
  const p = document.createElement('p');
  p.className = 'msg-sys';
  p.textContent = text;
  div.appendChild(p);
  div.scrollTop = div.scrollHeight;
}

// ====== è¿æ¥ ======
async function toggleConnect() {
  if (isConnected) {
    disconnect();
    return;
  }
  const apiKey = document.getElementById('apiKey').value.trim();
  if (!apiKey) { setStatus('è¯·å…ˆè¾“å…¥ API Key', 'err'); return; }

  const useJWT = document.getElementById('authMode').value === 'jwt';
  let token;
  if (useJWT) {
    setStatus('ç”Ÿæˆ JWT...', 'info');
    try {
      token = await generateJWT(apiKey);
      addSys('ğŸ”‘ JWT(å‰60å­—): ' + token.substring(0, 60) + '...');
    } catch(e) {
      setStatus('JWT ç”Ÿæˆå¤±è´¥: ' + e.message, 'err');
      return;
    }
  } else {
    token = apiKey;
    addSys('ğŸ”‘ ä½¿ç”¨åŸå§‹ API Key è®¤è¯');
  }

  const model = document.getElementById('model').value;
  // å›½é™…ç‰ˆç«¯ç‚¹ï¼ˆz.aiï¼‰é€‚åˆæµ·å¤–ç”¨æˆ·ï¼›å›½å†…ç‰ˆç”¨ open.bigmodel.cn
  const baseUrl = document.getElementById('region').value;
  const url = `${baseUrl}?Authorization=${encodeURIComponent('Bearer ' + token)}`;

  setStatus('è¿æ¥ä¸­...', 'info');
  try {
    ws = new WebSocket(url);
    ws.onopen = onWsOpen;
    ws.onmessage = onWsMessage;
    ws.onerror = (e) => setStatus('WebSocket é”™è¯¯', 'err');
    ws.onclose = (ev) => {
      isConnected = false;
      sessionReady = false;
      isMicActive = false;
      document.getElementById('btnConnect').textContent = 'è¿æ¥';
      document.getElementById('btnConnect').className = '';
      document.getElementById('btnMic').disabled = true;
      document.getElementById('btnMic').textContent = 'ğŸ¤ å¼€å§‹è¯´è¯';
      document.getElementById('btnMic').className = '';
      const codes = { 1000:'æ­£å¸¸å…³é—­', 1006:'å¼‚å¸¸æ–­å¼€', 1007:'æ— æ•ˆæ•°æ®', 1008:'ç­–ç•¥è¿è§„', 1011:'æœåŠ¡å™¨é”™è¯¯' };
      setStatus(`è¿æ¥å…³é—­: ${codes[ev.code]||'ä»£ç '+ev.code} ${ev.reason||''}`, 'err');
      addSys(`è¿æ¥å…³é—­ (${ev.code}) ${ev.reason||''}`);
      stopMic();
    };
  } catch(e) {
    setStatus('è¿æ¥å¤±è´¥: ' + e.message, 'err');
  }
}

function onWsOpen() {
  const model = document.getElementById('model').value;

  addSys('â³ WebSocket å·²è¿æ¥ï¼Œç­‰å¾… session.created...');

  isConnected = true;
  sessionReady = false;
  document.getElementById('btnConnect').textContent = 'æ–­å¼€';
  document.getElementById('btnConnect').className = 'connected';
  document.getElementById('btnMic').disabled = true;  // ç­‰ session.updated å†å¯ç”¨
  setStatus('å·²è¿æ¥ï¼Œç­‰å¾…ä¼šè¯åˆå§‹åŒ–...', 'info');
  addSys('âœ… WebSocket å·²è¿æ¥åˆ° ' + model);
}

function disconnect() {
  if (ws) { ws.close(); ws = null; }
  stopMic();
}

// ====== æ¶ˆæ¯å¤„ç† ======
function onWsMessage(ev) {
  // åŸå§‹æ—¥å¿— - æ˜¾ç¤ºå®Œæ•´æœåŠ¡å™¨æ¶ˆæ¯ï¼ˆåˆ†è¡Œæ˜¾ç¤ºï¼‰
  console.log('ğŸ“¨ RAW:', ev.data);
  addSys('ğŸ“¨ ' + ev.data.substring(0, 800));

  let msg;
  try { msg = JSON.parse(ev.data); } catch(e) { return; }

  switch(msg.type) {
    case 'session.created':
      addSys('âœ… session.created æ”¶åˆ°ï¼Œå‘é€ session.update...');
      isConnected = true;
      // æŒ‰ç…§å®˜æ–¹ SDK æ ¼å¼å‘é€å®Œæ•´çš„ session.update
      if (ws && ws.readyState === 1) {
        const voice = document.getElementById('voice').value;
        const sessionUpdate = {
          type: 'session.update',
          event_id: uuid(),
          client_timestamp: Date.now(),
          session: {
            turn_detection: { type: 'server_vad' },  // æœåŠ¡ç«¯è‡ªåŠ¨æ£€æµ‹è¯­éŸ³
            instructions: 'ä½ æ˜¯ä¸€ä¸ªå‹å¥½çš„ä¸­æ–‡AIåŠ©æ‰‹ï¼Œç”¨ç®€çŸ­è‡ªç„¶çš„ä¸­æ–‡å›ç­”é—®é¢˜ã€‚',
            output_audio_format: 'pcm',
            input_audio_format: 'wav',
            tools: null,
            beta_fields: {
              chat_mode: 'audio',
              tts_source: 'e2e'
            },
            voice: voice
          }
        };
        addSys('ğŸ“¤ session.update: ' + JSON.stringify(sessionUpdate).substring(0, 300));
        ws.send(JSON.stringify(sessionUpdate));
      }
      break;

    case 'session.updated':
      addSys('âœ… session.updated â€” é…ç½®å®Œæˆï¼Œå¯ä»¥è¯´è¯äº†ï¼');
      sessionReady = true;
      document.getElementById('btnMic').disabled = false;
      setStatus('ä¼šè¯å·²å°±ç»ªï¼Œç‚¹å‡»éº¦å…‹é£å¼€å§‹è¯´è¯', 'ok');
      break;

    case 'input_audio_buffer.speech_started':
      addSys('ğŸ™ï¸ æ£€æµ‹åˆ°è¯­éŸ³...');
      // æ‰“æ–­ AI è¯´è¯
      audioQueue = [];
      isPlayingAudio = false;
      break;

    case 'input_audio_buffer.speech_stopped':
      addSys('è¯­éŸ³ç»“æŸï¼Œå¤„ç†ä¸­...');
      break;

    case 'conversation.item.input_audio_transcription.completed':
      if (msg.transcript) {
        addMsg('user', msg.transcript);
      }
      break;

    case 'response.audio_transcript.delta':
      currentAiText += (msg.delta || '');
      break;

    case 'response.audio_transcript.done':
      if (currentAiText) {
        addMsg('ai', currentAiText);
        currentAiText = '';
      }
      break;

    case 'response.audio.delta':
      if (msg.delta) {
        enqueueAudio(msg.delta);
      }
      break;

    case 'response.done':
      addSys('å›ç­”å®Œæˆ');
      break;

    case 'error':
      setStatus('é”™è¯¯: ' + (msg.error?.message || JSON.stringify(msg.error)), 'err');
      addSys('âŒ é”™è¯¯: ' + (msg.error?.message || ''));
      break;
  }
}

// ====== éŸ³é¢‘æ’­æ”¾ï¼ˆPCM16 è¾“å‡ºï¼‰======
function enqueueAudio(base64Data) {
  const binary = atob(base64Data);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);

  // PCM16 â†’ Float32
  const pcm16 = new Int16Array(bytes.buffer);
  const float32 = new Float32Array(pcm16.length);
  for (let i = 0; i < pcm16.length; i++) float32[i] = pcm16[i] / 32768;

  audioQueue.push(float32);
  if (!isPlayingAudio) playNextChunk();
}

function playNextChunk() {
  if (audioQueue.length === 0) { isPlayingAudio = false; return; }
  isPlayingAudio = true;

  if (!audioContext) audioContext = new AudioContext({ sampleRate: 24000 });

  const chunk = audioQueue.shift();
  const buffer = audioContext.createBuffer(1, chunk.length, 24000);
  buffer.copyToChannel(chunk, 0);

  const src = audioContext.createBufferSource();
  src.buffer = buffer;
  src.connect(audioContext.destination);
  src.onended = playNextChunk;
  src.start();
}

// ====== éº¦å…‹é£ï¼ˆPCM16 è¾“å…¥ï¼‰======
async function toggleMic() {
  if (isMicActive) {
    stopMic();
    return;
  }
  try {
    if (!audioContext) audioContext = new AudioContext({ sampleRate: 16000 });
    else if (audioContext.sampleRate !== 16000) {
      audioContext = new AudioContext({ sampleRate: 16000 });
    }

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });

    const source = audioContext.createMediaStreamSource(micStream);

    // ScriptProcessor ç®€å•å®ç°ï¼ˆä¸ä¾èµ– AudioWorkletï¼‰
    const processor = audioContext.createScriptProcessor(4096, 1, 1);
    pcmChunks = [];
    let _audioSentCount = 0;
    let _audioSentBytes = 0;

    addSys(`ğŸ§ AudioContext å®é™…é‡‡æ ·ç‡: ${audioContext.sampleRate}Hz`);

    processor.onaudioprocess = (e) => {
      // æ¸…é›¶è¾“å‡ºï¼Œé˜²æ­¢éº¦å…‹é£ä¿¡å·å›æ”¾äº§ç”Ÿæ‚éŸ³
      const output = e.outputBuffer.getChannelData(0);
      for (let i = 0; i < output.length; i++) output[i] = 0;

      if (!isConnected || !isMicActive || !ws || ws.readyState !== 1) return;
      const float32 = e.inputBuffer.getChannelData(0);

      // æ£€æµ‹æ˜¯å¦æœ‰å£°éŸ³ï¼ˆéé™éŸ³ï¼‰
      let maxAmp = 0;
      const pcm16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        const s = float32[i];
        if (Math.abs(s) > maxAmp) maxAmp = Math.abs(s);
        pcm16[i] = Math.max(-32768, Math.min(32767, Math.round(s * 32768)));
      }

      pcmChunks.push(new Int16Array(pcm16));

      // æ¯ 2 ä¸ª chunk å‘é€ä¸€æ¬¡ï¼ˆ~500msï¼‰
      if (pcmChunks.length >= 2) {
        const totalSamples = pcmChunks.reduce((s, c) => s + c.length, 0);
        const merged = new Int16Array(totalSamples);
        let offset = 0;
        for (const chunk of pcmChunks) { merged.set(chunk, offset); offset += chunk.length; }
        pcmChunks = [];

        // æ„é€  WAV (16kHz mono 16bit)
        const sr = audioContext.sampleRate;
        const dataBytes = merged.buffer.byteLength;
        const wav = new ArrayBuffer(44 + dataBytes);
        const v = new DataView(wav);
        const ws2 = (s, o) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
        ws2('RIFF', 0); v.setUint32(4, 36 + dataBytes, true);
        ws2('WAVE', 8); ws2('fmt ', 12);
        v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, 1, true);
        v.setUint32(24, sr, true); v.setUint32(28, sr * 2, true);
        v.setUint16(32, 2, true); v.setUint16(34, 16, true);
        ws2('data', 36); v.setUint32(40, dataBytes, true);
        new Int16Array(wav, 44).set(merged);

        // base64 ç¼–ç ï¼ˆåˆ†å—é¿å…æ ˆæº¢å‡ºï¼‰
        const bytes = new Uint8Array(wav);
        let binaryStr = '';
        for (let i = 0; i < bytes.length; i += 8192) {
          binaryStr += String.fromCharCode.apply(null, bytes.subarray(i, i + 8192));
        }
        const base64 = btoa(binaryStr);

        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: base64, client_timestamp: Date.now() }));
          _audioSentCount++;
          _audioSentBytes += bytes.length;
          // æ¯ 4 æ¬¡å‘é€è®°å½•ä¸€æ¬¡æ—¥å¿—
          if (_audioSentCount % 4 === 1) {
            addSys(`ğŸ”Š å·²å‘é€ ${_audioSentCount} æ®µ (${(_audioSentBytes/1024).toFixed(0)}KB) æœ€å¤§æŒ¯å¹…=${maxAmp.toFixed(3)}`);
          }
        }
      }
    };

    source.connect(processor);
    processor.connect(audioContext.destination);
    micWorklet = { source, processor };

    isMicActive = true;
    document.getElementById('btnMic').textContent = 'ğŸ”´ åœæ­¢è¯´è¯';
    document.getElementById('btnMic').className = 'active';
    setStatus('ğŸ™ï¸ éº¦å…‹é£å·²å¼€å¯ï¼Œç›´æ¥è¯´è¯å³å¯ï¼ˆè‡ªåŠ¨æ£€æµ‹è¯­éŸ³ï¼‰', 'ok');
  } catch(e) {
    setStatus('éº¦å…‹é£é”™è¯¯: ' + e.message, 'err');
  }
}

function stopMic() {
  isMicActive = false;
  if (micWorklet) {
    try { micWorklet.processor.disconnect(); micWorklet.source.disconnect(); } catch(e){}
    micWorklet = null;
  }
  if (micStream) {
    micStream.getTracks().forEach(t => t.stop());
    micStream = null;
  }
  document.getElementById('btnMic').textContent = 'ğŸ¤ å¼€å§‹è¯´è¯';
  document.getElementById('btnMic').className = '';

  // server_vad æ¨¡å¼ä¸‹ä¸éœ€è¦æ‰‹åŠ¨ commitï¼ŒæœåŠ¡ç«¯è‡ªåŠ¨æ£€æµ‹
  // æ¸…ç†æ®‹ä½™ PCM æ•°æ®
  pcmChunks = [];
  addSys('ğŸ¤ éº¦å…‹é£å·²å…³é—­');
}
</script>
</body>
</html>
