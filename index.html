<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pocket Souls</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      background: #0a0a1a;
      overflow-x: hidden;
    }

    /* ============================================================
       Selector View
       ============================================================ */

    #selector-view {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      position: relative;
    }

    /* Animated background */
    #selector-view::before {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background:
        radial-gradient(ellipse at 20% 50%, rgba(90, 60, 180, 0.15) 0%, transparent 60%),
        radial-gradient(ellipse at 80% 50%, rgba(60, 130, 200, 0.1) 0%, transparent 60%),
        radial-gradient(ellipse at 50% 100%, rgba(100, 60, 150, 0.1) 0%, transparent 50%);
      z-index: 0;
      animation: bgShift 12s ease-in-out infinite alternate;
    }

    @keyframes bgShift {
      0% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    /* Floating particles */
    .particles {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: particleFloat linear infinite;
    }

    .particle.large {
      width: 3px;
      height: 3px;
      background: rgba(180, 160, 255, 0.5);
    }

    @keyframes particleFloat {
      0% { transform: translateY(100vh) translateX(0); opacity: 0; }
      5% { opacity: 1; }
      95% { opacity: 0.6; }
      100% { transform: translateY(-5vh) translateX(30px); opacity: 0; }
    }

    /* Title */
    .selector-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    .selector-title {
      font-size: 42px;
      font-weight: 200;
      letter-spacing: 8px;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 8px;
      text-transform: uppercase;
      animation: titleFadeIn 1s ease-out;
    }

    .selector-tagline {
      font-size: 15px;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: 3px;
      margin-bottom: 48px;
      animation: titleFadeIn 1s ease-out 0.2s both;
    }

    @keyframes titleFadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Carousel */
    .carousel {
      display: flex;
      justify-content: center;
      gap: 32px;
      padding: 20px;
      width: 100%;
      max-width: 700px;
      animation: cardsFadeIn 0.8s ease-out 0.4s both;
    }

    @keyframes cardsFadeIn {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Character Card */
    .character-card {
      position: relative;
      width: 260px;
      height: 440px;
      border-radius: 24px;
      overflow: hidden;
      cursor: pointer;
      flex-shrink: 0;
      transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1),
                  box-shadow 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .character-card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 24px;
      border: 2px solid rgba(255, 255, 255, 0.08);
      z-index: 3;
      transition: border-color 0.5s;
      pointer-events: none;
    }

    .character-card:hover {
      transform: translateY(-10px) scale(1.02);
    }

    .character-card.selected {
      transform: translateY(-14px) scale(1.04);
    }

    .character-card.selected::before {
      border-color: var(--card-accent, #fff);
    }

    /* Card glow effect */
    .card-glow {
      position: absolute;
      inset: -2px;
      border-radius: 26px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.5s;
      background: var(--card-accent, #7c6fe0);
      filter: blur(20px);
    }

    .character-card:hover .card-glow {
      opacity: 0.3;
    }

    .character-card.selected .card-glow {
      opacity: 0.5;
      animation: glowPulse 2.5s ease-in-out infinite;
    }

    @keyframes glowPulse {
      0%, 100% { opacity: 0.4; filter: blur(20px); }
      50% { opacity: 0.6; filter: blur(25px); }
    }

    /* Card media (video / image) */
    .card-media {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    .character-card:hover .card-media {
      transform: scale(1.05);
    }

    /* Card info overlay */
    .card-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 32px 24px 24px;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.85));
      z-index: 2;
    }

    .card-name {
      font-size: 26px;
      font-weight: 700;
      color: #fff;
      margin-bottom: 6px;
      letter-spacing: 1px;
    }

    .card-tagline {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.6);
      line-height: 1.4;
    }

    /* Enter button */
    .enter-btn {
      margin-top: 40px;
      padding: 16px 52px;
      font-size: 17px;
      font-weight: 600;
      border: none;
      border-radius: 999px;
      color: white;
      cursor: pointer;
      letter-spacing: 2px;
      transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      animation: cardsFadeIn 0.8s ease-out 0.6s both;
    }

    .enter-btn:disabled {
      opacity: 0.3;
      cursor: default;
      transform: none;
    }

    .enter-btn:not(:disabled) {
      background: linear-gradient(135deg, var(--btn-bg, #7c6fe0), var(--btn-bg-dark, #5a4fbf));
      box-shadow: 0 4px 24px var(--btn-glow, rgba(124, 111, 224, 0.4));
    }

    .enter-btn:not(:disabled):hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 36px var(--btn-glow, rgba(124, 111, 224, 0.5));
    }

    .enter-btn:not(:disabled):active {
      transform: translateY(-1px);
    }

    /* Selector exit animation */
    #selector-view.exit {
      animation: selectorExit 0.7s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    @keyframes selectorExit {
      to {
        opacity: 0;
        transform: scale(1.08);
        filter: blur(10px);
      }
    }

    /* Mobile carousel */
    @media (max-width: 600px) {
      .selector-title { font-size: 32px; letter-spacing: 5px; }
      .selector-tagline { margin-bottom: 32px; }

      .carousel {
        justify-content: flex-start;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 20px calc(50% - 140px);
        gap: 20px;
      }
      .carousel::-webkit-scrollbar { display: none; }

      .character-card {
        width: 280px;
        height: 460px;
        scroll-snap-align: center;
      }
    }

    /* ============================================================
       Chat View
       ============================================================ */

    #chat-view {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      min-height: 100vh;
      animation: chatEnter 0.6s ease-out;
    }

    @keyframes chatEnter {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Back button */
    .back-btn {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 100;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.6);
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .back-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border-color: rgba(255, 255, 255, 0.2);
    }

    /* Chat header */
    .chat-header {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      color: #fff;
      margin-bottom: 6px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      font-size: 28px;
    }

    .subtitle {
      color: rgba(255,255,255,0.7);
      margin-bottom: 20px;
      font-size: 14px;
    }

    .avatar-container {
      width: 360px;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 20px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      transition: box-shadow 0.3s;
      /* 移动端：GPU 级别裁剪，防止合成层溢出 border-radius 边界 */
      clip-path: inset(0 round 20px);
      contain: paint;
    }

    .avatar-container.voice-active {
      box-shadow: 0 0 0 3px rgba(232,133,51,0.6), 0 10px 40px rgba(0,0,0,0.4);
      animation: voice-pulse 2s ease-in-out infinite;
    }

    @keyframes voice-pulse {
      0%, 100% { box-shadow: 0 0 0 3px rgba(232,133,51,0.4), 0 10px 40px rgba(0,0,0,0.4); }
      50% { box-shadow: 0 0 0 6px rgba(232,133,51,0.6), 0 10px 40px rgba(0,0,0,0.4); }
    }

    .avatar-container img,
    .avatar-container video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
      /* GPU 合成层，移动端减少重绘卡顿 */
      transform: translateZ(0);
      will-change: opacity;
    }

    #idle-image { z-index: 1; }
    .idle-layer {
      z-index: 2;
      opacity: 0;
      /* 无过渡：idle 切换瞬间完成，action 层在上面负责交叉淡化 */
    }
    .idle-layer.visible { opacity: 1; }
    .action-layer {
      z-index: 3;
      opacity: 0;
      transition: opacity 0.35s ease-in-out;
    }
    .action-layer.visible { opacity: 1; }

    .voice-section {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .voice-btn {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      color: white;
      box-shadow: 0 4px 20px rgba(232,133,51,0.4);
    }

    .voice-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 25px rgba(232,133,51,0.5);
    }

    .voice-btn.active {
      background: linear-gradient(135deg, #e85c5c 0%, #c44646 100%) !important;
      box-shadow: 0 4px 20px rgba(232,92,92,0.5);
      animation: mic-pulse 1.5s ease-in-out infinite;
    }

    @keyframes mic-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }

    .voice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      animation: none;
    }

    .voice-status {
      color: rgba(255,255,255,0.7);
      font-size: 13px;
      text-align: center;
      min-height: 20px;
    }

    .action-section {
      margin-top: 24px;
      max-width: 420px;
      width: 100%;
    }

    .section-label {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      padding-left: 4px;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .action-btn {
      padding: 12px 22px;
      font-size: 15px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      color: white;
      font-weight: 500;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .action-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
    .action-btn:active { transform: translateY(0); }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

    .settings-toggle {
      margin-top: 16px;
      background: none;
      border: none;
      color: rgba(255,255,255,0.4);
      cursor: pointer;
      font-size: 13px;
      transition: color 0.2s;
    }
    .settings-toggle:hover { color: rgba(255,255,255,0.7); }

    .settings-panel {
      margin-top: 8px;
      max-width: 420px;
      width: 100%;
      display: none;
    }
    .settings-panel.open { display: block; }

    .settings-panel label {
      color: rgba(255,255,255,0.5);
      font-size: 12px;
      display: block;
      margin-bottom: 4px;
    }

    .settings-panel input, .settings-panel select {
      width: 100%;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .status {
      color: rgba(255,255,255,0.7);
      margin-top: 16px;
      font-size: 14px;
      text-align: center;
    }

    /* ============================================================
       Mobile Chat View
       ============================================================ */
    @media (max-width: 600px) {
      #chat-view {
        padding: 12px 10px;
      }

      .chat-header h1 { font-size: 22px; margin-bottom: 2px; }
      .chat-header .subtitle { font-size: 12px; margin-bottom: 12px; }

      .avatar-container {
        width: calc(100vw - 24px);
        max-width: 360px;
        border-radius: 16px;
        /* 限制高度，确保语音按钮可见 */
        max-height: 60vh;
        max-height: 60svh; /* svh: 排除手机地址栏的实际视口高度 */
      }

      .voice-section { margin-top: 14px; gap: 6px; }
      .voice-btn { width: 56px; height: 56px; font-size: 24px; }
      .voice-status { font-size: 12px; }

      .action-section { margin-top: 16px; }
      .section-label { font-size: 11px; margin-bottom: 6px; }

      .action-btn { padding: 10px 16px; font-size: 13px; border-radius: 10px; }

      .settings-toggle { font-size: 12px; margin-top: 12px; }
      .settings-panel { max-width: 100%; }
      .settings-panel input, .settings-panel select { font-size: 13px; }

      .status { font-size: 13px; margin-top: 12px; }

      .back-btn { width: 36px; height: 36px; font-size: 16px; top: 10px; left: 10px; }
    }

    /* 小屏手机（如 iPhone SE 375px） */
    @media (max-width: 380px) {
      .avatar-container {
        width: calc(100vw - 16px);
        border-radius: 12px;
      }
      .action-btn { padding: 8px 12px; font-size: 12px; }
    }
  </style>
</head>
<body>

  <!-- ===== Character Selector ===== -->
  <div id="selector-view">
    <div class="particles" id="particles"></div>
    <div class="selector-content">
      <h1 class="selector-title">Pocket Souls</h1>
      <p class="selector-tagline">选择你的数字伙伴</p>
      <div class="carousel" id="carousel"></div>
      <button class="enter-btn" id="enter-btn" disabled>选择伙伴</button>
    </div>
  </div>

  <!-- ===== Chat Interface ===== -->
  <div id="chat-view" style="display:none">
    <button class="back-btn" id="back-btn" title="切换角色">&#8592;</button>

    <div class="chat-header">
      <h1 id="char-name">Loading...</h1>
      <p class="subtitle" id="char-subtitle"></p>
    </div>

    <div class="avatar-container" id="avatar-container">
      <img id="idle-image" alt="Avatar" />
      <video id="idle-video" class="idle-layer" playsinline webkit-playsinline muted loop preload="auto"></video>
      <video id="idle-video-b" class="idle-layer" playsinline webkit-playsinline muted preload="none"></video>
      <video id="action-video" class="action-layer" playsinline webkit-playsinline muted preload="none"></video>
      <video id="action-video-b" class="action-layer" playsinline webkit-playsinline muted preload="none"></video>
    </div>

    <div class="voice-section">
      <button class="voice-btn" id="voice-btn" title="开始语音对话">&#x1F3A4;</button>
      <p class="voice-status" id="voice-status">点击麦克风开始语音对话</p>
    </div>

    <div class="action-section" id="basic-section">
      <div class="section-label">基础动作</div>
      <div class="action-buttons" id="basic-buttons"></div>
    </div>

    <div class="action-section" id="fun-section">
      <div class="section-label">趣味互动</div>
      <div class="action-buttons" id="fun-buttons"></div>
    </div>

    <p class="status" id="status">加载中...</p>

    <!-- 连接诊断面板 -->
    <button class="settings-toggle" id="diag-toggle">&#x1F4CB; 连接诊断</button>
    <div class="settings-panel" id="diag-panel">
      <div id="diag-output" style="background:rgba(0,0,0,0.5);color:#ff0;font-family:monospace;font-size:11px;padding:12px;border-radius:8px;max-height:300px;overflow-y:auto;white-space:pre-wrap;">等待语音对话开始...</div>
    </div>

    <!-- 记忆调试面板 -->
    <button class="settings-toggle" id="debug-toggle">&#x1F50D; 记忆调试</button>
    <div class="settings-panel" id="debug-panel">
      <div id="debug-output" style="background:rgba(0,0,0,0.5);color:#0f0;font-family:monospace;font-size:12px;padding:12px;border-radius:8px;max-height:300px;overflow-y:auto;white-space:pre-wrap;"></div>
      <div style="margin-top:8px;display:flex;gap:8px;">
        <button id="debug-refresh" style="padding:6px 12px;border:none;border-radius:6px;background:#4a7c34;color:#fff;cursor:pointer;font-size:12px;">&#x1F504; 刷新</button>
        <button id="debug-clear" style="padding:6px 12px;border:none;border-radius:6px;background:#c44646;color:#fff;cursor:pointer;font-size:12px;">&#x1F5D1; 清除全部记忆</button>
      </div>
    </div>

    <!-- 设置 -->
    <button class="settings-toggle" id="settings-toggle">&#x2699;&#xFE0F; 设置</button>
    <div class="settings-panel" id="settings-panel">
      <label>语音引擎</label>
      <select id="engine-select">
        <option value="gemini">Gemini Live（海外推荐）</option>
        <option value="glm">GLM-Realtime 智谱（国内推荐）</option>
        <option value="qwen">通义千问 Qwen（国内推荐）</option>
      </select>
      <div id="gemini-settings">
        <label>Gemini API Key</label>
        <input type="password" id="api-key-input" placeholder="输入你的 Gemini API Key" />
      </div>
      <div id="glm-settings" style="display:none">
        <label>GLM API Key（格式：id.secret）</label>
        <input type="password" id="glm-api-key-input" placeholder="输入你的 GLM API Key" />
      </div>
      <div id="qwen-settings" style="display:none">
        <label>DashScope API Key</label>
        <input type="password" id="qwen-api-key-input" placeholder="输入你的阿里云 DashScope API Key" />
        <div style="font-size:11px;color:#aaa;margin-top:4px;line-height:1.5">
          ⚠️ Qwen 需先启动本地代理：<br>
          <code style="background:#1a1a2e;padding:2px 4px;border-radius:3px">node qwen-proxy.js</code>
        </div>
      </div>
      <label id="speed-label">语速 <span id="speed-value">1.0x</span></label>
      <input type="range" id="speed-range" min="0.8" max="1.5" step="0.1" value="1.0"
        style="width:100%;margin-bottom:10px;accent-color:var(--btn-bg,#7c6fe0);" />
      <label>语音音色</label>
      <select id="voice-select">
        <option value="Puck">Puck（俏皮活泼）</option>
        <option value="Leda">Leda（年轻可爱）</option>
        <option value="Fenrir">Fenrir（兴奋活力）</option>
        <option value="Aoede">Aoede（轻盈清新）</option>
        <option value="Kore">Kore（清亮坚定）</option>
        <option value="Achernar">Achernar（柔和温暖）</option>
      </select>
    </div>
  </div>

  <!-- 共享模块 -->
  <script src="modules/memory-manager.js"></script>
  <script src="modules/prompt-composer.js"></script>
  <script src="modules/tool-handler.js"></script>
  <script src="modules/glm-client.js"></script>
  <script src="modules/qwen-client.js"></script>

  <script>
    // ============================================================
    // Section 0: 角色选择器
    // ============================================================

    // ============================================================
    // 诊断日志系统（页面内可见 + console）
    // ============================================================
    const _diagLogs = [];
    function diagLog(msg) {
      const ts = new Date().toLocaleTimeString('zh-CN', { hour12: false });
      const entry = `[${ts}] ${msg}`;
      _diagLogs.push(entry);
      if (_diagLogs.length > 100) _diagLogs.shift();
      console.log('[Diag]', msg);
      // 同步到调试面板（如果打开）
      const el = document.getElementById('diag-output');
      if (el) {
        el.textContent = _diagLogs.slice(-30).join('\n');
        el.scrollTop = el.scrollHeight;
      }
    }

    let CHARACTER_ID = null;
    let CHARACTER_PATH = '';
    let CHARACTER = null;
    let ACTIONS = {};
    let ACTION_LABELS = {};

    const selectorView = document.getElementById('selector-view');
    const chatView = document.getElementById('chat-view');
    const enterBtn = document.getElementById('enter-btn');
    const carousel = document.getElementById('carousel');

    // 生成背景粒子
    function createParticles() {
      const container = document.getElementById('particles');
      for (let i = 0; i < 40; i++) {
        const p = document.createElement('div');
        p.className = 'particle' + (Math.random() > 0.7 ? ' large' : '');
        p.style.left = Math.random() * 100 + '%';
        p.style.animationDuration = (8 + Math.random() * 15) + 's';
        p.style.animationDelay = -(Math.random() * 20) + 's';
        container.appendChild(p);
      }
    }

    // 加载角色选择器
    async function loadSelector() {
      createParticles();

      const res = await fetch('characters/index.json');
      const characterIds = await res.json();

      // 并行加载所有角色配置
      const configs = await Promise.all(
        characterIds.map(async (id) => {
          const r = await fetch(`characters/${id}/config.json`);
          return r.json();
        })
      );

      let selectedId = null;

      configs.forEach((config) => {
        const card = document.createElement('div');
        card.className = 'character-card';
        card.dataset.id = config.id;
        card.style.setProperty('--card-accent', config.theme.accent);

        // 光晕层
        const glow = document.createElement('div');
        glow.className = 'card-glow';
        glow.style.background = config.theme.accent;
        card.appendChild(glow);

        // 视频 / 图片背景
        const video = document.createElement('video');
        video.className = 'card-media';
        // 优先使用 idle sequence 的第一个，否则用 idle.mp4
        const idleSrc = (config.idle && config.idle.sequence)
          ? `characters/${config.id}/assets/${config.idle.sequence[0]}`
          : `characters/${config.id}/assets/idle.mp4`;
        video.src = idleSrc;
        video.poster = `characters/${config.id}/assets/idle.jpg`;
        video.autoplay = true;
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.preload = 'metadata';  // 移动端只加载元数据，节省带宽
        // 视频加载失败时降级到图片
        video.addEventListener('error', () => {
          const img = document.createElement('img');
          img.className = 'card-media';
          img.src = `characters/${config.id}/assets/idle.jpg`;
          card.replaceChild(img, video);
        }, { once: true });
        card.appendChild(video);

        // 信息覆层
        const overlay = document.createElement('div');
        overlay.className = 'card-overlay';
        overlay.innerHTML = `
          <div class="card-name">${config.name}</div>
          <div class="card-tagline">${config.tagline || config.subtitle}</div>
        `;
        card.appendChild(overlay);

        // 点击选择
        card.addEventListener('click', () => {
          document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
          card.classList.add('selected');
          selectedId = config.id;
          enterBtn.disabled = false;
          enterBtn.textContent = `进入${config.name}的世界`;
          enterBtn.style.setProperty('--btn-bg', config.theme.accent);
          enterBtn.style.setProperty('--btn-bg-dark', config.theme.accentDark);
          enterBtn.style.setProperty('--btn-glow', config.theme.accent + '66');
        });

        carousel.appendChild(card);
      });

      // 进入按钮
      enterBtn.addEventListener('click', () => {
        if (!selectedId) return;
        enterChat(selectedId);
      });

      // 移动端：监听滚动自动选中
      if (window.innerWidth <= 600) {
        let scrollTimer = null;
        carousel.addEventListener('scroll', () => {
          clearTimeout(scrollTimer);
          scrollTimer = setTimeout(() => {
            const cards = carousel.querySelectorAll('.character-card');
            const center = carousel.scrollLeft + carousel.offsetWidth / 2;
            let closest = null;
            let closestDist = Infinity;
            cards.forEach(c => {
              const cardCenter = c.offsetLeft + c.offsetWidth / 2;
              const dist = Math.abs(center - cardCenter);
              if (dist < closestDist) { closestDist = dist; closest = c; }
            });
            if (closest && !closest.classList.contains('selected')) {
              closest.click();
            }
          }, 100);
        });
      }
    }

    // 从选择器进入对话
    function enterChat(characterId) {
      CHARACTER_ID = characterId;
      CHARACTER_PATH = `characters/${CHARACTER_ID}`;

      // 更新 URL（不刷新页面）
      const url = new URL(location);
      url.searchParams.set('c', characterId);
      history.replaceState({}, '', url);

      // 退出动画
      selectorView.classList.add('exit');

      setTimeout(() => {
        selectorView.style.display = 'none';
        chatView.style.display = '';

        // 加载角色并初始化
        loadCharacter().then(() => {
          const iv = document.getElementById('idle-video');
          iv.addEventListener('canplay', () => {
            iv.classList.add('visible');
            iv.play().catch(() => {});
          }, { once: true });
          iv.load();
        }).catch(err => {
          document.getElementById('status').textContent = `加载角色失败: ${err.message}`;
        });
      }, 650);
    }

    // 启动：检查 URL 参数
    const urlCharId = new URLSearchParams(location.search).get('c');
    if (urlCharId) {
      // 直接进入对话
      CHARACTER_ID = urlCharId;
      CHARACTER_PATH = `characters/${CHARACTER_ID}`;
      selectorView.style.display = 'none';
      chatView.style.display = '';

      loadCharacter().then(() => {
        const iv = document.getElementById('idle-video');
        iv.addEventListener('canplay', () => {
          iv.classList.add('visible');
          iv.play().catch(() => {});
        }, { once: true });
        iv.load();
      }).catch(err => {
        document.getElementById('status').textContent = `加载角色失败: ${err.message}`;
      });
    } else {
      // 显示角色选择器
      loadSelector();
    }

    // 返回按钮：回到选择器
    document.getElementById('back-btn').addEventListener('click', () => {
      // 移除 URL 参数，刷新页面回到选择器
      const url = new URL(location);
      url.searchParams.delete('c');
      location.href = url.toString();
    });

    // ============================================================
    // Section 1: 角色配置加载
    // ============================================================

    async function loadCharacter() {
      const res = await fetch(`${CHARACTER_PATH}/config.json`);
      if (!res.ok) throw new Error(`角色 "${CHARACTER_ID}" 不存在`);
      CHARACTER = await res.json();

      // 设置页面
      document.title = `${CHARACTER.name} - Pocket Souls`;
      document.getElementById('char-name').textContent = CHARACTER.name;
      document.getElementById('char-subtitle').textContent = CHARACTER.subtitle;
      document.body.style.background = CHARACTER.theme.background;

      // 设置按钮主题色
      const accent = CHARACTER.theme.accent;
      const accentDark = CHARACTER.theme.accentDark;
      document.querySelector('.voice-btn').style.background =
        `linear-gradient(135deg, ${accent} 0%, ${accentDark} 100%)`;

      // 构建 ACTIONS 和 ACTION_LABELS
      const allActions = [...CHARACTER.actions.basic, ...CHARACTER.actions.fun];
      for (const a of allActions) {
        if (a.sequence) {
          // 顺序播放序列：存储为数组
          ACTIONS[a.id] = a.sequence.map(f => `${CHARACTER_PATH}/assets/${f}`);
          ACTION_LABELS[a.id] = a.status;
        } else {
          const fileName = a.file || `${a.id}.mp4`;
          ACTIONS[a.id] = `${CHARACTER_PATH}/assets/${fileName}`;
          ACTION_LABELS[a.id] = a.status;
        }
      }
      // speaking_v2 兼容（仅在非 sequence 模式下）
      if (!Array.isArray(ACTIONS['speaking'])) {
        ACTIONS['speaking_v2'] = `${CHARACTER_PATH}/assets/speaking_v2.mp4`;
        ACTION_LABELS['speaking_v2'] = ACTION_LABELS['speaking'];
      }

      // 渲染动作按钮
      renderButtons('basic-buttons', CHARACTER.actions.basic, accent, accentDark);
      renderButtons('fun-buttons', CHARACTER.actions.fun,
        CHARACTER.theme.fun, CHARACTER.theme.funDark);

      // 设置 idle 素材
      document.getElementById('idle-image').src = `${CHARACTER_PATH}/assets/idle.jpg`;
      if (CHARACTER.idle && CHARACTER.idle.sequence) {
        // 顺序循环模式：idel1 → idel2 → idel1 → ...
        _idleSequence = CHARACTER.idle.sequence.map(f => `${CHARACTER_PATH}/assets/${f}`);
        _idleSeqIndex = 0;
        idleVideo.loop = false;
        idleBuffer.loop = false;
        idleVideo.src = _idleSequence[0];
        // 预加载第二个到 buffer
        _preloadNextIdle();
      } else {
        _idleSequence = null;
        idleVideo.src = `${CHARACTER_PATH}/assets/idle.mp4`;
      }

      // 设置默认语音（根据当前引擎）
      updateEngineUI();

      // 更新状态文字
      document.getElementById('status').textContent = `点击按钮和${CHARACTER.name}互动吧~`;
      document.getElementById('voice-status').textContent = `点击麦克风和${CHARACTER.name}语音对话`;
    }

    function renderButtons(containerId, actions, bg, bgDark) {
      const container = document.getElementById(containerId);
      for (const a of actions) {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.dataset.action = a.id;
        btn.style.background = `linear-gradient(135deg, ${bg} 0%, ${bgDark} 100%)`;
        btn.textContent = `${a.emoji} ${a.label}`;
        btn.addEventListener('click', () => playManualAction(a.id));
        container.appendChild(btn);
      }
    }

    // ============================================================
    // Section 2: 常量
    // ============================================================
    const FADE_MS = 350;
    const LOOP_END_THRESHOLD = 0.5;
    const MAX_WAIT = 3000;

    const GEMINI_WS_URL = 'wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent';
    const GEMINI_MODEL = 'models/gemini-2.5-flash-native-audio-latest';

    // 模块实例
    let memoryManager = null;
    let promptComposer = null;
    let toolHandler = null;

    // ============================================================
    // Section 3: DOM 元素
    // ============================================================
    const idleVideoA     = document.getElementById('idle-video');
    const idleVideoB     = document.getElementById('idle-video-b');
    const actionVideoA   = document.getElementById('action-video');
    const actionVideoB   = document.getElementById('action-video-b');

    // 双缓冲：当前播放 / 预加载
    let idleVideo  = idleVideoA;   // 当前活跃的 idle
    let idleBuffer = idleVideoB;   // 预加载的 idle
    let actionVideo  = actionVideoA;  // 当前活跃的 action
    let actionBuffer = actionVideoB;  // 预加载的 action
    const statusEl       = document.getElementById('status');
    const voiceBtn       = document.getElementById('voice-btn');
    const voiceStatusEl  = document.getElementById('voice-status');
    const avatarContainer = document.getElementById('avatar-container');
    const settingsToggle = document.getElementById('settings-toggle');
    const settingsPanel  = document.getElementById('settings-panel');
    const apiKeyInput    = document.getElementById('api-key-input');
    const voiceSelect    = document.getElementById('voice-select');

    // ============================================================
    // Section 4: 状态变量
    // ============================================================
    let isManualPlaying = false;
    let pendingAction = null;
    let waitTimer = null;
    let isVoiceChatActive = false;
    let currentAvatarState = 'idle';

    // idle 顺序循环
    let _idleSequence = null;   // null=单视频loop, 数组=顺序播放
    let _idleSeqIndex = 0;

    // ============================================================
    // Section 5: 设置面板
    // ============================================================

    // 引擎切换
    const engineSelect    = document.getElementById('engine-select');
    const geminiSettings  = document.getElementById('gemini-settings');
    const glmSettings     = document.getElementById('glm-settings');
    const qwenSettings    = document.getElementById('qwen-settings');
    const glmApiKeyInput  = document.getElementById('glm-api-key-input');
    const qwenApiKeyInput = document.getElementById('qwen-api-key-input');

    const GEMINI_VOICES = [
      { value: 'Puck', label: 'Puck（俏皮活泼）' },
      { value: 'Leda', label: 'Leda（年轻可爱）' },
      { value: 'Fenrir', label: 'Fenrir（兴奋活力）' },
      { value: 'Aoede', label: 'Aoede（轻盈清新）' },
      { value: 'Kore', label: 'Kore（清亮坚定）' },
      { value: 'Achernar', label: 'Achernar（柔和温暖）' },
    ];
    const GLM_VOICES = [
      { value: 'tongtong', label: 'tongtong（通用女声·默认）' },
      { value: 'female-tianmei', label: 'female-tianmei（甜美女声）' },
      { value: 'female-shaonv', label: 'female-shaonv（少女音）' },
      { value: 'lovely_girl', label: 'lovely_girl（可爱女孩）' },
      { value: 'xiaochen', label: 'xiaochen（通用男声）' },
      { value: 'male-qn-daxuesheng', label: 'male-qn-daxuesheng（大学生男声）' },
      { value: 'male-qn-jingying', label: 'male-qn-jingying（精英男声）' },
    ];
    const QWEN_VOICES = [
      // ── 女声·甜美/温柔 ──
      { value: 'Cherry', label: 'Cherry（阳光亲切小姐姐）' },
      { value: 'Serena', label: 'Serena（温柔小姐姐）' },
      { value: 'Mia', label: 'Mia（温柔似水）' },
      { value: 'Seren', label: 'Seren（舒缓治愈·助眠）' },
      { value: 'Chelsie', label: 'Chelsie（二次元虚拟女友）' },
      // ── 女声·少女/可爱 ──
      { value: 'Bunny', label: 'Bunny（满溢可爱小女孩）' },
      { value: 'Stella', label: 'Stella（甜美正义少女）' },
      { value: 'Nini', label: 'Nini（软糯粘人）' },
      { value: 'Momo', label: 'Momo（撒娇搞怪）' },
      // ── 女声·个性 ──
      { value: 'Vivian', label: 'Vivian（傲娇小暴躁）' },
      { value: 'Bella', label: 'Bella（率性小姐姐）' },
      { value: 'Maia', label: 'Maia（知性温柔）' },
      { value: 'Ebona', label: 'Ebona（低语暗黑风）' },
      { value: 'Bellona', label: 'Bellona（有力·角色配音）' },
      // ── 女声·国际/成熟 ──
      { value: 'Jennifer', label: 'Jennifer（高级美式女声）' },
      { value: 'Katerina', label: 'Katerina（成熟韵味女声）' },
      { value: 'Sonrisa', label: 'Sonrisa（开朗拉美女性）' },
      // ── 女声·方言 ──
      { value: 'Jada', label: 'Jada（上海阿姨）' },
      { value: 'Sunny', label: 'Sunny（四川妹子）' },
      { value: 'Kiki', label: 'Kiki（香港闺蜜·粤语）' },
      // ── 女声·学术 ──
      { value: 'Elias', label: 'Elias（学术教学·故事化）' },
      // ── 男声·阳光/温暖 ──
      { value: 'Ethan', label: 'Ethan（阳光温暖·标准普通话）' },
      { value: 'Aiden', label: 'Aiden（阳光美式男声）' },
      { value: 'Mochi', label: 'Mochi（聪慧童心青年）' },
      // ── 男声·帅气/率性 ──
      { value: 'Moon', label: 'Moon（率性帅气）' },
      { value: 'Nofish', label: 'Nofish（趣味设计师）' },
      { value: 'Ryan', label: 'Ryan（戏剧张力·节奏感）' },
      { value: 'Lenn', label: 'Lenn（理性叛逆·德系青年）' },
      // ── 男声·成熟/磁性 ──
      { value: 'Kai', label: 'Kai（低沉舒缓·耳朵SPA）' },
      { value: 'Andre', label: 'Andre（磁性沉稳）' },
      { value: 'Neil', label: 'Neil（专业新闻主播）' },
      { value: 'Vincent', label: 'Vincent（沙哑烟嗓·英雄感）' },
      // ── 男声·长者 ──
      { value: 'Eldric Sage', label: 'Eldric Sage（睿智长者）' },
      { value: 'Arthur', label: 'Arthur（朴实老人）' },
      // ── 男声·少年 ──
      { value: 'Pip', label: 'Pip（淘气小男孩）' },
      { value: 'Ono Anna', label: 'Ono Anna（青梅竹马少年）' },
      // ── 男声·国际 ──
      { value: 'Bodega', label: 'Bodega（热情西班牙）' },
      { value: 'Alek', label: 'Alek（冷暖俄罗斯）' },
      { value: 'Dolce', label: 'Dolce（慵懒意大利）' },
      { value: 'Sohee', label: 'Sohee（温暖韩国）' },
      { value: 'Emilien', label: 'Emilien（浪漫法国大哥哥）' },
      { value: 'Radio Gol', label: 'Radio Gol（足球解说员）' },
      // ── 男声·方言 ──
      { value: 'Dylan', label: 'Dylan（北京爷们·京味）' },
      { value: 'Li', label: 'Li（南京瑜伽老师）' },
      { value: 'Marcus', label: 'Marcus（陕西味·朴实）' },
      { value: 'Roy', label: 'Roy（台湾小哥·闽南语）' },
      { value: 'Peter', label: 'Peter（天津相声捧哏）' },
      { value: 'Eric', label: 'Eric（成都四川话）' },
      { value: 'Rocky', label: 'Rocky（幽默阿强·粤语）' },
    ];

    function updateEngineUI() {
      const engine = engineSelect.value;
      geminiSettings.style.display = engine === 'gemini' ? '' : 'none';
      glmSettings.style.display    = engine === 'glm'    ? '' : 'none';
      qwenSettings.style.display   = engine === 'qwen'   ? '' : 'none';
      // 切换音色列表
      const voices = engine === 'qwen' ? QWEN_VOICES :
                     engine === 'glm'  ? GLM_VOICES :
                     GEMINI_VOICES;
      const savedVoice = localStorage.getItem(engine + '_voice') || voices[0].value;
      voiceSelect.innerHTML = '';
      for (const v of voices) {
        const opt = document.createElement('option');
        opt.value = v.value;
        opt.textContent = v.label;
        if (v.value === savedVoice) opt.selected = true;
        voiceSelect.appendChild(opt);
      }
    }

    // 恢复设置
    engineSelect.value = localStorage.getItem('voice_engine') || 'gemini';
    apiKeyInput.value = localStorage.getItem('gemini_api_key') || '';
    glmApiKeyInput.value = localStorage.getItem('glm_api_key') || '';
    qwenApiKeyInput.value = localStorage.getItem('qwen_api_key') || '';
    updateEngineUI();

    engineSelect.addEventListener('change', () => {
      localStorage.setItem('voice_engine', engineSelect.value);
      updateEngineUI();
    });
    apiKeyInput.addEventListener('change', () => {
      localStorage.setItem('gemini_api_key', apiKeyInput.value);
    });
    glmApiKeyInput.addEventListener('change', () => {
      localStorage.setItem('glm_api_key', glmApiKeyInput.value);
    });
    qwenApiKeyInput.addEventListener('change', () => {
      localStorage.setItem('qwen_api_key', qwenApiKeyInput.value);
    });
    voiceSelect.addEventListener('change', () => {
      localStorage.setItem(engineSelect.value + '_voice', voiceSelect.value);
    });

    // 语速控制
    const speedRange = document.getElementById('speed-range');
    const speedValue = document.getElementById('speed-value');
    speedRange.value = localStorage.getItem('playback_speed') || '1.0';
    speedValue.textContent = speedRange.value + 'x';
    speedRange.addEventListener('input', () => {
      speedValue.textContent = speedRange.value + 'x';
      localStorage.setItem('playback_speed', speedRange.value);
      // 实时更新播放速度
      if (audioStreamer) audioStreamer.playbackRate = parseFloat(speedRange.value);
    });

    settingsToggle.addEventListener('click', () => {
      settingsPanel.classList.toggle('open');
    });

    // 连接诊断面板
    document.getElementById('diag-toggle').addEventListener('click', () => {
      document.getElementById('diag-panel').classList.toggle('open');
    });

    // 记忆调试面板
    const debugToggle = document.getElementById('debug-toggle');
    const debugPanel = document.getElementById('debug-panel');
    const debugOutput = document.getElementById('debug-output');

    debugToggle.addEventListener('click', async () => {
      debugPanel.classList.toggle('open');
      if (debugPanel.classList.contains('open')) {
        await refreshDebugInfo();
      }
    });

    document.getElementById('debug-refresh').addEventListener('click', () => {
      refreshDebugInfo();
    });

    document.getElementById('debug-clear').addEventListener('click', async () => {
      const dbName = CHARACTER ? CHARACTER.dbName : 'fox-companion';
      if (!confirm('确定要清除所有记忆吗？（用户画像、语义记忆、互动日志全部清除）')) return;
      try {
        if (memoryManager && memoryManager.db) {
          memoryManager.db.close();
          memoryManager = null;
          promptComposer = null;
          toolHandler = null;
        }
        const req = indexedDB.deleteDatabase(dbName);
        req.onsuccess = () => {
          debugOutput.textContent = '✅ 记忆已全部清除！下次对话将从零开始。';
        };
        req.onerror = () => {
          debugOutput.textContent = '❌ 清除失败: ' + req.error;
        };
      } catch (e) {
        debugOutput.textContent = '❌ 清除失败: ' + e.message;
      }
    });

    async function refreshDebugInfo() {
      const lines = [];
      if (!memoryManager) {
        lines.push('⚠️ MemoryManager 尚未初始化（需要先开启一次语音对话）');
        debugOutput.textContent = lines.join('\n');
        return;
      }
      try {
        const profile = await memoryManager.getUserProfile();
        lines.push('=== 用户画像 (IndexedDB) ===');
        if (Object.keys(profile).length === 0) {
          lines.push('  （空 - save_user_profile 工具未被调用过）');
        } else {
          for (const [k, v] of Object.entries(profile)) {
            lines.push(`  ${k}: ${v}`);
          }
        }
        lines.push('\n=== 语义记忆 ===');
        const stats = await memoryManager.getStats();
        lines.push(`  总记忆数: ${stats.totalMemories}`);
        lines.push(`  互动日志: ${stats.totalEpisodes}`);
        lines.push(`  有画像: ${stats.hasProfile}`);
        if (stats.byCategory && Object.keys(stats.byCategory).length > 0) {
          lines.push(`  分类: ${JSON.stringify(stats.byCategory)}`);
        }
        const allMemories = await memoryManager.searchMemory('');
        if (allMemories.length > 0) {
          lines.push('\n=== 记忆详情 ===');
          for (const m of allMemories) {
            const conf = (m.confidence || 1.0).toFixed(2);
            lines.push(`  [${m.category}] ${m.content} (置信度:${conf})`);
          }
        }
        lines.push('\n=== 提示 ===');
        lines.push('打开浏览器控制台 (F12/Cmd+Opt+I)');
        lines.push('搜索 [Tool] 查看 Function Calling 日志');
      } catch (e) {
        lines.push(`错误: ${e.message}`);
      }
      debugOutput.textContent = lines.join('\n');
    }

    // ============================================================
    // Section 6: Avatar 状态控制
    // ============================================================

    const _avatarVideoCache = {};   // 相对路径 → true/false
    let _avatarErrorCount = 0;
    const MAX_AVATAR_ERRORS = 3;
    let _currentVideoPath = null;   // 当前正在加载的视频相对路径
    let _suppressVideoErrors = false; // 清理视频时抑制 error 事件

    // speaking 顺序播放索引（sequence 模式）
    let _speakingSeqIndex = 0;
    // speaking 交替播放：speaking ↔ speaking_v2（旧模式兼容）
    let _speakingToggle = false;  // false=speaking, true=speaking_v2

    // idle 双缓冲：预加载下一个，播完瞬间切换
    function _preloadNextIdle() {
      if (!_idleSequence || _idleSequence.length < 2) return;
      const nextIdx = (_idleSeqIndex + 1) % _idleSequence.length;
      idleBuffer.src = _idleSequence[nextIdx];
      idleBuffer.load();
    }

    function _onIdleEnded() {
      if (!_idleSequence || _idleSequence.length === 0) return;
      if (currentAvatarState !== 'idle') return;
      // 手动动作期间完全跳过：不交换、不预加载，idle 保持当前帧静止
      if (isManualPlaying) return;

      _idleSeqIndex = (_idleSeqIndex + 1) % _idleSequence.length;
      idleBuffer.classList.add('visible');
      idleBuffer.play().catch(() => {});
      idleVideo.classList.remove('visible');
      // 交换角色
      const tmp = idleVideo;
      idleVideo = idleBuffer;
      idleBuffer = tmp;
      // 预加载下一个
      _preloadNextIdle();
    }

    idleVideoA.addEventListener('ended', _onIdleEnded);
    idleVideoB.addEventListener('ended', _onIdleEnded);

    // 安全清除 action 视频的 src，不触发 error 事件
    function clearActionVideos() {
      _suppressVideoErrors = true;
      actionVideo.pause();
      actionVideo.removeAttribute('src');
      actionVideo.classList.remove('visible');
      actionVideo.load();
      actionBuffer.pause();
      actionBuffer.removeAttribute('src');
      actionBuffer.classList.remove('visible');
      actionBuffer.load();
      _currentVideoPath = null;
      setTimeout(() => { _suppressVideoErrors = false; }, 50);
    }

    // speaking 双缓冲：预加载下一个 speaking 片段
    function _preloadNextSpeaking() {
      const actionDef = ACTIONS['speaking'];
      if (!Array.isArray(actionDef) || actionDef.length < 2) return;
      const nextIdx = (_speakingSeqIndex + 1) % actionDef.length;
      const nextSrc = actionDef[nextIdx];
      if (_avatarVideoCache[nextSrc] === false) return;
      actionBuffer.src = nextSrc;
      actionBuffer.muted = true;
      actionBuffer.load();
    }

    function setAvatarState(newState) {
      if (newState === currentAvatarState) return;
      currentAvatarState = newState;

      if (newState === 'idle') {
        _speakingSeqIndex = 0;
        // 先显示 idle（瞬间，在 action 下面），再淡出 action
        idleVideo.classList.add('visible');
        if (_idleSequence) {
          _idleSeqIndex = 0;
          idleBuffer.classList.remove('visible');
          idleVideo.src = _idleSequence[0];
          idleVideo.load();
          _preloadNextIdle();
        }
        if (idleVideo.paused) idleVideo.play().catch(() => {});
        // action 层淡出（350ms transition），露出下面的 idle
        actionVideo.classList.remove('visible');
        actionBuffer.classList.remove('visible');
        actionVideo.loop = false;
        setTimeout(() => { clearActionVideos(); }, FADE_MS);
        statusEl.textContent = isVoiceChatActive
          ? '语音对话中...'
          : `点击按钮和${CHARACTER?.name || ''}互动吧~`;
        return;
      }

      // 解析视频源：支持 sequence 数组和单文件
      const actionDef = ACTIONS[newState];
      let videoSrc;
      let isSequence = false;

      if (Array.isArray(actionDef)) {
        // sequence 模式（speaking 等）
        isSequence = true;
        _speakingSeqIndex = 0;
        videoSrc = actionDef[0];
      } else {
        videoSrc = actionDef;
        // 旧模式兼容：speaking_v2 交替
        if (newState === 'speaking' && _speakingToggle && ACTIONS['speaking_v2']) {
          const v2Src = ACTIONS['speaking_v2'];
          if (_avatarVideoCache[v2Src] !== false) {
            videoSrc = v2Src;
          }
        }
      }
      if (!videoSrc) return;

      if (_avatarVideoCache[videoSrc] === false) {
        console.warn(`跳过已知不可用的视频: ${newState}`);
        return;
      }

      if (_avatarErrorCount >= MAX_AVATAR_ERRORS) {
        console.warn(`连续视频错误 ${_avatarErrorCount} 次，暂停视频切换`);
        return;
      }

      _currentVideoPath = videoSrc;
      actionVideo.src = videoSrc;
      actionVideo.loop = !isSequence && !(newState === 'speaking' && ACTIONS['speaking_v2']);
      actionVideo.muted = true;
      actionVideo.load();

      // sequence 模式预加载下一个到 buffer
      if (isSequence && newState === 'speaking') {
        _preloadNextSpeaking();
      }

      statusEl.textContent = ACTION_LABELS[newState] || '';

      const onReady = () => {
        actionVideo.removeEventListener('canplay', onReady);
        _avatarVideoCache[videoSrc] = true;
        _avatarErrorCount = 0;
        // action 层淡入（z-index 3，在 idle 上面），idle 保持可见不闪
        actionVideo.classList.add('visible');
        actionVideo.play().catch(() => {});
        // action 淡入完成后再隐藏 idle（节省资源）
        setTimeout(() => {
          if (currentAvatarState !== 'idle') {
            idleVideo.classList.remove('visible');
            idleBuffer.classList.remove('visible');
          }
        }, FADE_MS);
      };
      actionVideo.addEventListener('canplay', onReady);
    }

    // speaking 视频播完时顺序切换（双缓冲 sequence 或旧 v2 模式）
    function _onSpeakingEnded() {
      if (currentAvatarState !== 'speaking') return;
      if (!isVoiceChatActive) return;

      const actionDef = ACTIONS['speaking'];

      if (Array.isArray(actionDef)) {
        // sequence 双缓冲：buffer 已预加载，瞬间切换
        _speakingSeqIndex = (_speakingSeqIndex + 1) % actionDef.length;
        const nextSrc = actionDef[_speakingSeqIndex];
        if (_avatarVideoCache[nextSrc] === false) {
          _speakingSeqIndex = 0;
          actionVideo.play().catch(() => {});
          return;
        }
        // 瞬间切换到 buffer（action 层有 transition 但这里需要立即切换）
        actionBuffer.style.transition = 'none';
        actionBuffer.classList.add('visible');
        actionBuffer.play().catch(() => {});
        actionVideo.style.transition = 'none';
        actionVideo.classList.remove('visible');
        // 交换角色
        const tmp = actionVideo;
        actionVideo = actionBuffer;
        actionBuffer = tmp;
        _currentVideoPath = nextSrc;
        // 恢复 transition（用于回到 idle 时的淡出）
        requestAnimationFrame(() => requestAnimationFrame(() => {
          actionVideoA.style.transition = '';
          actionVideoB.style.transition = '';
        }));
        // 预加载下一个
        _preloadNextSpeaking();
      } else if (ACTIONS['speaking_v2']) {
        // 旧模式兼容：speaking ↔ speaking_v2
        _speakingToggle = !_speakingToggle;
        const nextSrc = _speakingToggle ? ACTIONS['speaking_v2'] : ACTIONS['speaking'];
        if (_avatarVideoCache[nextSrc] === false) {
          _speakingToggle = false;
          actionVideo.play().catch(() => {});
          return;
        }
        _currentVideoPath = nextSrc;
        actionVideo.src = nextSrc;
        actionVideo.load();
        actionVideo.play().catch(() => {});
      }
    }

    actionVideoA.addEventListener('ended', _onSpeakingEnded);
    actionVideoB.addEventListener('ended', _onSpeakingEnded);

    // ============================================================
    // Section 7: 手动动作系统
    // ============================================================

    // 手动动作安全计时器（防止 ended 不触发导致卡死）
    let _manualSafetyTimer = null;

    function playManualAction(action) {
      if (isManualPlaying || isVoiceChatActive) return;
      let videoSrc = ACTIONS[action];
      if (!videoSrc) return;
      // sequence 模式手动点击只播第一个
      if (Array.isArray(videoSrc)) videoSrc = videoSrc[0];

      // 重置 actionVideo 指向 A，避免语音对话双缓冲交换后的残留状态
      actionVideo  = actionVideoA;
      actionBuffer = actionVideoB;

      isManualPlaying = true;
      pendingAction = action;
      setButtonsEnabled(false);
      statusEl.textContent = '准备中...';

      // 确保两个 action 元素都干净
      actionVideoA.classList.remove('visible');
      actionVideoB.classList.remove('visible');

      actionVideo.loop = false;
      actionVideo.muted = true;
      actionVideo.src = videoSrc;
      actionVideo.load();
    }

    function _onManualCanPlay() {
      if (!pendingAction || isVoiceChatActive) return;
      const action = pendingAction;
      pendingAction = null;

      const duration = idleVideo.duration || 6;
      const currentTime = idleVideo.currentTime || 0;
      const remaining = (duration - currentTime) * 1000;

      if (remaining < LOOP_END_THRESHOLD * 1000 || remaining > MAX_WAIT) {
        executeManualCrossfade(action);
      } else {
        statusEl.textContent = '准备中...';
        waitTimer = setTimeout(() => {
          executeManualCrossfade(action);
        }, remaining - LOOP_END_THRESHOLD * 1000);
      }
    }
    actionVideoA.addEventListener('canplay', _onManualCanPlay);
    actionVideoB.addEventListener('canplay', _onManualCanPlay);

    function executeManualCrossfade(action) {
      waitTimer = null;
      actionVideo.classList.add('visible');
      // idle 保持可见（z-index 2 在 action z-index 3 下面），action 淡入自然覆盖
      statusEl.textContent = ACTION_LABELS[action] || '正在播放...';
      setTimeout(() => {
        actionVideo.play().catch(err => {
          console.error('播放失败:', err);
          resetToIdle();
        });
      }, FADE_MS * 0.5);

      // 安全计时器：视频最长 15 秒，如果 ended 没触发就强制复位
      if (_manualSafetyTimer) clearTimeout(_manualSafetyTimer);
      _manualSafetyTimer = setTimeout(() => {
        if (isManualPlaying && !isVoiceChatActive) {
          console.warn('手动动作安全计时器触发，强制复位');
          _finishManualAction();
        }
      }, 15000);
    }

    function _finishManualAction() {
      if (_manualSafetyTimer) { clearTimeout(_manualSafetyTimer); _manualSafetyTimer = null; }
      // idle 一直在 z-index 2 下面可见，确保在播放（sequence 模式可能已 ended）
      if (idleVideo.paused || idleVideo.ended) {
        idleVideo.currentTime = 0;
        idleVideo.play().catch(() => {});
      }
      // 只淡出 action 层（z-index 3），idle 自然露出
      actionVideoA.classList.remove('visible');
      actionVideoB.classList.remove('visible');
      setTimeout(() => {
        clearActionVideos();
        isManualPlaying = false;
        setButtonsEnabled(true);
        statusEl.textContent = `点击按钮和${CHARACTER?.name || ''}互动吧~`;
      }, FADE_MS);
    }

    function _onManualEnded() {
      // 带 loop 的不处理
      if (this.loop) return;
      // 语音对话中由 _onSpeakingEnded 处理
      if (isVoiceChatActive) return;
      _finishManualAction();
    }
    actionVideoA.addEventListener('ended', _onManualEnded);
    actionVideoB.addEventListener('ended', _onManualEnded);

    function _onManualError() {
      // 清理视频时触发的 error 忽略掉，防止死循环
      if (_suppressVideoErrors) return;

      // 用相对路径做缓存（和 setAvatarState 查询一致）
      if (_currentVideoPath) {
        _avatarVideoCache[_currentVideoPath] = false;
        console.warn(`视频加载失败 (${_avatarErrorCount + 1}/${MAX_AVATAR_ERRORS}): ${_currentVideoPath}`);
      }
      _avatarErrorCount++;

      if (isVoiceChatActive) {
        actionVideo.classList.remove('visible');
        actionBuffer.classList.remove('visible');
        idleVideo.classList.add('visible');
        clearActionVideos();
        currentAvatarState = 'idle';
        return;
      }
      statusEl.textContent = '视频加载失败，请先生成视频素材';
      resetToIdle();
    }
    actionVideoA.addEventListener('error', _onManualError);
    actionVideoB.addEventListener('error', _onManualError);

    function resetToIdle() {
      if (waitTimer) { clearTimeout(waitTimer); waitTimer = null; }
      if (_manualSafetyTimer) { clearTimeout(_manualSafetyTimer); _manualSafetyTimer = null; }
      actionVideoA.classList.remove('visible');
      actionVideoB.classList.remove('visible');
      clearActionVideos();
      actionVideo.loop = false;
      pendingAction = null;
      isManualPlaying = false;
      currentAvatarState = 'idle';
      setButtonsEnabled(!isVoiceChatActive);
      statusEl.textContent = isVoiceChatActive
        ? '语音对话中...'
        : `点击按钮和${CHARACTER?.name || ''}互动吧~`;
      if (idleVideo.paused) idleVideo.play().catch(() => {});
      idleVideo.classList.add('visible');
    }

    function setButtonsEnabled(enabled) {
      document.querySelectorAll('.action-btn').forEach(btn => { btn.disabled = !enabled; });
    }

    // ============================================================
    // Section 8: 音频播放器
    // ============================================================

    class AudioStreamer {
      constructor(sampleRate = 24000, playbackRate = 1.0) {
        this.sampleRate = sampleRate;
        this.playbackRate = playbackRate;
        this.context = null;
        this.gainNode = null;
        this.scheduledTime = 0;
        this.sources = [];
        this._checkTimer = null;
      }

      _ensureContext() {
        if (!this.context || this.context.state === 'closed') {
          this.context = new AudioContext({ sampleRate: this.sampleRate });
          this.gainNode = this.context.createGain();
          this.gainNode.connect(this.context.destination);
          this.scheduledTime = 0;
        }
        if (this.context.state === 'suspended') this.context.resume();
      }

      addPCM16(base64Data) {
        this._ensureContext();
        const raw = atob(base64Data);
        const bytes = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
        const int16 = new Int16Array(bytes.buffer);
        const float32 = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

        const buffer = this.context.createBuffer(1, float32.length, this.sampleRate);
        buffer.getChannelData(0).set(float32);
        const source = this.context.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = this.playbackRate;
        source.connect(this.gainNode);

        const now = this.context.currentTime;
        const startAt = Math.max(now + 0.02, this.scheduledTime);
        source.start(startAt);
        this.scheduledTime = startAt + buffer.duration / this.playbackRate;
        this.sources.push(source);
        source.onended = () => {
          this.sources = this.sources.filter(s => s !== source);
        };
      }

      get isPlaying() {
        return this.context && this.scheduledTime > this.context.currentTime;
      }

      stop() {
        if (this._checkTimer) { clearInterval(this._checkTimer); this._checkTimer = null; }
        this.sources.forEach(s => { try { s.stop(); } catch(e) {} });
        this.sources = [];
        if (this.gainNode) {
          this.gainNode.disconnect();
          this.gainNode = this.context.createGain();
          this.gainNode.connect(this.context.destination);
        }
        this.scheduledTime = 0;
      }

      waitForEnd(callback) {
        if (this._checkTimer) clearInterval(this._checkTimer);
        this._checkTimer = setInterval(() => {
          if (!this.isPlaying) {
            clearInterval(this._checkTimer);
            this._checkTimer = null;
            callback();
          }
        }, 100);
      }
    }

    // ============================================================
    // Section 9: 麦克风录音器
    // ============================================================

    class MicRecorder {
      constructor(onChunk) {
        this.onChunk = onChunk;
        this.stream = null;
        this.audioContext = null;
        this.processor = null;
        this.analyser = null;
        this.levelData = null;
      }

      async start() {
        this.stream = await navigator.mediaDevices.getUserMedia({
          audio: { channelCount: 1, sampleRate: 16000, echoCancellation: true,
                   noiseSuppression: true, autoGainControl: true }
        });
        this.audioContext = new AudioContext({ sampleRate: 16000 });
        const source = this.audioContext.createMediaStreamSource(this.stream);
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 512;
        this.levelData = new Uint8Array(this.analyser.frequencyBinCount);
        source.connect(this.analyser);

        await this.audioContext.audioWorklet.addModule('audio-processor.js');
        this.processor = new AudioWorkletNode(this.audioContext, 'audio-recorder-worklet');
        this.processor.port.onmessage = (event) => {
          if (event.data.event === 'chunk') {
            this.onChunk(this._arrayBufferToBase64(event.data.data));
          }
        };
        source.connect(this.processor);
      }

      getLevel() {
        if (!this.analyser || !this.levelData) return 0;
        this.analyser.getByteFrequencyData(this.levelData);
        return this.levelData.reduce((a, b) => a + b, 0) / this.levelData.length;
      }

      stop() {
        if (this.processor) this.processor.disconnect();
        if (this.audioContext) this.audioContext.close().catch(() => {});
        if (this.stream) this.stream.getTracks().forEach(t => t.stop());
        this.processor = null; this.audioContext = null; this.stream = null;
      }

      _arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
      }
    }

    // ============================================================
    // Section 10: Gemini Live WebSocket 客户端
    // ============================================================

    class GeminiLiveClient {
      constructor(apiKey, voice, systemPrompt, functionDeclarations) {
        this.apiKey = apiKey;
        this.voice = voice;
        this.systemPrompt = systemPrompt;
        this.functionDeclarations = functionDeclarations || [];
        this.ws = null;
        this.onAudio = null;
        this.onTurnComplete = null;
        this.onInterrupted = null;
        this.onToolCall = null;
        this.onError = null;
        this.onClose = null;
      }

      connect() {
        return new Promise((resolve, reject) => {
          const url = `${GEMINI_WS_URL}?key=${this.apiKey}`;
          this.ws = new WebSocket(url);
          const timeout = setTimeout(() => reject(new Error('连接超时')), 15000);

          this.ws.onopen = () => {
            const setupMsg = {
              setup: {
                model: GEMINI_MODEL,
                generationConfig: {
                  responseModalities: ['AUDIO'],
                  speechConfig: {
                    voiceConfig: { prebuiltVoiceConfig: { voiceName: this.voice } }
                  }
                },
                systemInstruction: { parts: [{ text: this.systemPrompt }] }
              }
            };
            if (this.functionDeclarations.length > 0) {
              setupMsg.setup.tools = [{ functionDeclarations: this.functionDeclarations }];
            }
            this.ws.send(JSON.stringify(setupMsg));
          };

          this.ws.onmessage = async (event) => {
            try {
              const text = typeof event.data === 'string' ? event.data : await event.data.text();
              const response = JSON.parse(text);

              if (response.setupComplete) { clearTimeout(timeout); resolve(); return; }

              if (response.toolCall) {
                console.log('[Gemini] 收到 toolCall:', JSON.stringify(response.toolCall).substring(0, 500));
                if (this.onToolCall) this.onToolCall(response.toolCall);
                return;
              }

              if (!response.serverContent?.modelTurn?.parts?.some(p => p.inlineData)) {
                console.log('[Gemini] 非音频响应:', JSON.stringify(response).substring(0, 300));
              }

              if (response.serverContent) {
                const sc = response.serverContent;
                if (sc.interrupted) { if (this.onInterrupted) this.onInterrupted(); return; }
                if (sc.modelTurn) {
                  for (const part of (sc.modelTurn.parts || [])) {
                    if (part.inlineData?.mimeType?.startsWith('audio/pcm')) {
                      if (this.onAudio) this.onAudio(part.inlineData.data);
                    }
                  }
                }
                if (sc.turnComplete) { if (this.onTurnComplete) this.onTurnComplete(); }
              }
            } catch (e) { console.error('解析消息失败:', e); }
          };

          this.ws.onerror = (err) => { clearTimeout(timeout); reject(err); if (this.onError) this.onError(err); };
          this.ws.onclose = (ev) => {
            const reason = ev.reason || '(无原因)';
            const codeMap = { 1000: '正常关闭', 1001: '离开', 1006: '异常断开', 1008: '策略违规', 1011: '服务器错误' };
            const desc = codeMap[ev.code] || `代码${ev.code}`;
            console.error(`[WS] 连接关闭: ${desc}, reason="${reason}", wasClean=${ev.wasClean}`);
            diagLog(`连接关闭: ${desc} | ${reason}`);
            if (this.onClose) this.onClose();
          };
        });
      }

      sendAudio(base64Data) {
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({
            realtimeInput: { mediaChunks: [{ mimeType: 'audio/pcm;rate=16000', data: base64Data }] }
          }));
        }
      }

      sendToolResponse(functionResponses) {
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ toolResponse: { functionResponses } }));
        }
      }

      disconnect() { if (this.ws) { this.ws.close(); this.ws = null; } }
    }

    // ============================================================
    // Section 11: 语音对话控制器
    // ============================================================

    let geminiClient = null;
    let micRecorder = null;
    let audioStreamer = null;
    let vadTimer = null;
    let userSpeaking = false;
    let modelSpeaking = false;
    let silenceStart = 0;

    const VAD_THRESHOLD = 12;
    const SILENCE_DELAY = 600;
    const THINK_DELAY = 300;

    voiceBtn.addEventListener('click', () => {
      if (isVoiceChatActive) stopVoiceChat(); else startVoiceChat();
    });

    async function startVoiceChat() {
      const engine = engineSelect.value;
      const apiKey = engine === 'qwen' ? qwenApiKeyInput.value.trim()
                   : engine === 'glm'  ? glmApiKeyInput.value.trim()
                   : apiKeyInput.value.trim();

      if (!apiKey) {
        settingsPanel.classList.add('open');
        const keyInput = engine === 'qwen' ? qwenApiKeyInput
                       : engine === 'glm'  ? glmApiKeyInput
                       : apiKeyInput;
        keyInput.focus();
        const engineName = engine === 'qwen' ? 'DashScope' : engine === 'glm' ? 'GLM' : 'Gemini';
        voiceStatusEl.textContent = `请先输入 ${engineName} API Key`;
        return;
      }
      const keyName = engine === 'qwen' ? 'qwen_api_key'
                    : engine === 'glm'  ? 'glm_api_key'
                    : 'gemini_api_key';
      localStorage.setItem(keyName, apiKey);

      voiceBtn.disabled = true;
      voiceStatusEl.textContent = '初始化记忆系统...';

      try {
        if (!memoryManager) {
          memoryManager = new MemoryManager(CHARACTER.dbName);
          await memoryManager.init();
          memoryManager.runMaintenance().catch(e => {
            console.warn('[Memory] 维护失败:', e);
          });
        }
        if (!promptComposer) {
          promptComposer = new PromptComposer(memoryManager);
          await promptComposer.loadSoul(`${CHARACTER_PATH}/SOUL.md`);
        }
        if (!toolHandler) {
          toolHandler = new ToolHandler(memoryManager);
        }

        voiceStatusEl.textContent = '组合人设记忆...';
        const systemPrompt = await promptComposer.compose();
        const functionDeclarations = toolHandler.getFunctionDeclarations();
        console.log('[Soul] System prompt 长度:', systemPrompt.length);
        console.log('[Tools] 工具数量:', functionDeclarations.length);

        const engineLabel = engine === 'qwen' ? 'Qwen' : engine === 'glm' ? 'GLM' : 'Gemini';
        voiceStatusEl.textContent = `连接 ${engineLabel}...`;
        const voice = voiceSelect.value;

        // 根据引擎创建对应客户端
        let liveClient;
        if (engine === 'qwen') {
          liveClient = new QwenLiveClient(apiKey, voice, systemPrompt, functionDeclarations);
        } else if (engine === 'glm') {
          liveClient = new GLMLiveClient(apiKey, voice, systemPrompt, functionDeclarations);
        } else {
          liveClient = new GeminiLiveClient(apiKey, voice, systemPrompt, functionDeclarations);
        }
        geminiClient = liveClient;  // 复用变量名，接口一致

        let _audioChunkCount = 0;  // 用于跳过 GLM 回复开头的提示音
        liveClient.onAudio = (base64) => {
          _audioChunkCount++;
          // GLM VAD 检测后前 2 个音频包可能含提示音，跳过
          if (engine === 'glm' && _audioChunkCount <= 2) return;
          if (!modelSpeaking) { modelSpeaking = true; setAvatarState('speaking'); }
          audioStreamer.addPCM16(base64);
        };
        liveClient.onTurnComplete = () => {
          _audioChunkCount = 0;  // 重置，下次回复重新计数
          audioStreamer.waitForEnd(() => { modelSpeaking = false; setAvatarState('idle'); });
        };
        liveClient.onInterrupted = () => {
          _audioChunkCount = 0;
          audioStreamer.stop(); modelSpeaking = false; setAvatarState('listening');
        };
        liveClient.onClose = () => {
          diagLog('onClose 回调触发，isVoiceChatActive=' + isVoiceChatActive);
          if (isVoiceChatActive) { voiceStatusEl.textContent = '连接已断开（查看连接诊断）'; stopVoiceChat(); }
        };

        liveClient.onToolCall = async (toolCall) => {
          const t0 = performance.now();
          const functionCalls = toolCall.functionCalls || [];
          diagLog(`收到 toolCall: ${functionCalls.map(c => c.name).join(', ')} (${functionCalls.length}个)`);

          const functionResponses = [];
          for (const call of functionCalls) {
            const callId = call.id || '(no-id)';
            diagLog(`  执行: ${call.name}(${JSON.stringify(call.args || {}).substring(0, 80)}) id=${callId}`);
            const t1 = performance.now();
            let result;
            try {
              result = await toolHandler.execute(call.name, call.args || {});
              diagLog(`  完成: ${call.name} ${(performance.now() - t1).toFixed(0)}ms`);
            } catch (e) {
              diagLog(`  出错: ${call.name} ${e.message}`);
              result = { error: e.message || '工具执行失败' };
            }
            functionResponses.push({ response: result, id: call.id });
          }

          const wsState = liveClient?.ws?.readyState;
          diagLog(`发送 toolResponse (ws状态=${wsState}, 耗时=${(performance.now() - t0).toFixed(0)}ms)`);
          try {
            liveClient.sendToolResponse(functionResponses);
            diagLog('toolResponse 已发送');
          } catch (e) {
            diagLog(`toolResponse 发送失败: ${e.message}`);
          }
        };

        await liveClient.connect();
        diagLog(`${engine.toUpperCase()} WebSocket 已连接`);
        const speed = parseFloat(localStorage.getItem('playback_speed') || '1.0');
        audioStreamer = new AudioStreamer(24000, speed);
        micRecorder = new MicRecorder((chunk) => liveClient.sendAudio(chunk));
        await micRecorder.start();
        diagLog('麦克风已启动，开始对话');

        isVoiceChatActive = true;
        voiceBtn.disabled = false;
        voiceBtn.classList.add('active');
        voiceBtn.textContent = '⏹';
        voiceBtn.title = '结束对话';
        avatarContainer.classList.add('voice-active');
        setButtonsEnabled(false);
        settingsPanel.classList.remove('open');
        voiceStatusEl.textContent = '语音对话中 - 请开始说话~';
        statusEl.textContent = '语音对话中...';

        // GLM 使用 server_vad，不需要客户端 VAD 来切换 avatar 状态
        // 但仍然用客户端 VAD 做视觉反馈（listening/think 动画）
        startVAD();

      } catch (err) {
        console.error('语音对话启动失败:', err);
        voiceStatusEl.textContent = `启动失败: ${err.message || '请检查 API Key'}`;
        voiceBtn.disabled = false;
        cleanup();
      }
    }

    function stopVoiceChat() {
      isVoiceChatActive = false;
      cleanup();
      voiceBtn.classList.remove('active');
      voiceBtn.textContent = '🎤';
      voiceBtn.title = '开始语音对话';
      voiceBtn.disabled = false;
      avatarContainer.classList.remove('voice-active');
      voiceStatusEl.textContent = `点击麦克风和${CHARACTER?.name || ''}语音对话`;
      resetToIdle();
      setButtonsEnabled(true);

      if (memoryManager) {
        memoryManager.saveEpisode('进行了一次语音对话').catch(e => {
          console.warn('保存互动日志失败:', e);
        });
      }
    }

    function cleanup() {
      stopVAD();
      if (audioStreamer) { audioStreamer.stop(); audioStreamer = null; }
      if (micRecorder) { micRecorder.stop(); micRecorder = null; }
      if (geminiClient) { geminiClient.disconnect(); geminiClient = null; }
      userSpeaking = false; modelSpeaking = false;
    }

    // ============================================================
    // Section 12: 语音活动检测 (VAD)
    // ============================================================

    function startVAD() {
      let thinkTimer = null;
      vadTimer = setInterval(() => {
        if (!micRecorder || !isVoiceChatActive) return;
        const level = micRecorder.getLevel();

        if (level > VAD_THRESHOLD) {
          if (!userSpeaking) {
            userSpeaking = true;
            if (thinkTimer) { clearTimeout(thinkTimer); thinkTimer = null; }
            if (!modelSpeaking) setAvatarState('listening');
          }
          silenceStart = 0;
        } else if (userSpeaking) {
          if (!silenceStart) silenceStart = Date.now();
          if (Date.now() - silenceStart > SILENCE_DELAY) {
            userSpeaking = false;
            silenceStart = 0;
            if (!modelSpeaking) {
              thinkTimer = setTimeout(() => {
                if (!modelSpeaking && !userSpeaking && isVoiceChatActive) setAvatarState('think');
              }, THINK_DELAY);
            }
          }
        }
      }, 50);
    }

    function stopVAD() {
      if (vadTimer) { clearInterval(vadTimer); vadTimer = null; }
    }
  </script>
</body>
</html>
